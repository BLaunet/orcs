#!/usr/bin/python2.7
# *-* coding: utf-8 *-*
# author : Thomas Martin (thomas.martin.1@ulaval.ca)


from orcs import *
from utils import *

class Denoiser(ORCSTools):
    """This class can be used to remove fringes and more generally
    deconvolve the spectrum of the variable modulation efficiency
    function.
    """
    
    def __init__(self, option_file_path, image_list_path,
                 order, step, object_name, phase_map_0_path,
                 phase_coeff_1, calib_map_path, zpd_shift,
                 apod = '1.5', add_pi=False,
                 config_file_name="config.orb", overwrite=True,
                 old_spectrum_cube_path=None):

        # Load options file
        self.options = OptionFile(option_file_path)
        
        self.cube = Cube(image_list_path)
        self.dimx = self.cube.dimx
        self.dimy = self.cube.dimy
        self.dimz = self.cube.dimz

        self.object_name = object_name
        
        self.nm_laser = float(self._get_config_parameter(
            "CALIB_NM_LASER",
            config_file_name=config_file_name))
        self.apod = apod
        self.zpd_shift = zpd_shift
        self.order = order
        self.step = step
        self.lines = np.array(self.options.get_lines(), dtype=float)
        self.lines_shift = float(self.options['SHIFT'])
        self.lines_fwhm = float(self.options['FWHM'])
        
        self._data_prefix = self._get_data_prefix()
        self._data_path_hdr = self._get_data_path_hdr()
        self.overwrite = overwrite

        self.phase_map = self.read_fits(phase_map_0_path)
        if add_pi: self.phase_map += math.pi
        self.calib_map = self.read_fits(calib_map_path)
        self.phase_coeff_1 = phase_coeff_1

        if old_spectrum_cube_path != None:
            self.fits_hdr = self.read_fits(old_spectrum_cube_path,
                                           return_hdu_only=True)[0].header


    def _get_data_prefix(self):
        return (os.curdir + os.sep + self.object_name + '_denoise' + os.sep
                + self.object_name + '_')

    def get_noise_cube_path(self, real=True):
        if real: real='real'
        else: real='imag'
        return self._data_path_hdr + "noise_cube.%s.fits"%real

    def get_corrected_cube_path(self, real=True, spectrum=True,
                                defringed=False):
        if real: real='real'
        else: real='imag'
        if spectrum: spectrum='spectrum'
        else: spectrum='interf'
        if defringed: defringed='.defringed'
        else: defringed=''
            
        return self._data_path_hdr + "corrected_%s_cube%s.%s.fits"%(
            spectrum, defringed, real)

    def get_noise_vector_path(self, real=True):
        if real: real='real'
        else: real='imag'
        return self._data_path_hdr + "noise_vector.%s.fits"%real

    def compute_noise_vector(self, x_range=None, y_range=None,
                             use_defringed_interf=False):

        def _compute_noise_in_column(interf_cube_col, phase_map_col,
                                     phase_coeff_1, nm_laser, calib_map_col,
                                     step, order, zpd_shift, apod, lines):
            
            dimy = interf_cube_col.shape[0]
            dimz = interf_cube_col.shape[1]
            noise_cube_col = np.empty_like(interf_cube_col, dtype=complex)
            noise_cube_col.fill(np.nan)
            
            for ij in range(dimy):
                # define phase
                coeffs_list = [phase_map_col[ij],
                               phase_coeff_1]
                ext_phase = np.polynomial.polynomial.polyval(
                    np.arange(dimz), coeffs_list)
                
                interf = interf_cube_col[ij,:]

                if (np.any(interf)
                    and np.all(~np.isnan(interf))
                    and np.all(~np.isinf(interf))):
                    
                    spectrum = transform_interferogram(
                        interf, nm_laser, nm_laser,
                        step, order, apod, zpd_shift,
                        ext_phase=ext_phase,
                        return_complex=True)

                    interf2 = transform_spectrum(
                        spectrum, nm_laser, nm_laser,
                        step, order, None, zpd_shift,
                        ext_phase=ext_phase,
                        return_complex=True)

                    fitted_spectrum = np.empty(dimz, dtype=complex)
                    fitted_spectrum.fill(np.nan)
                    
                    cm_axis = create_cm_axis(dimz, step, order,
                                             corr=calib_map_col[ij]/nm_laser)
                    lines_pix = nm2pix(cm_axis, lines)
                    
                    fit_real = fit_lines_in_vector(
                        spectrum.real, lines_pix,
                        fwhm_guess=3.5, return_fitted_vector=True,
                        no_absorption=True,
                        height_guess=0., fix_height=True, fit_tol=1e-2)
                    fit_imag = fit_lines_in_vector(
                        - spectrum.imag, lines_pix,
                        fwhm_guess=3.5, return_fitted_vector=True,
                        no_absorption=True,
                        height_guess=0., fix_height=True, fit_tol=1e-2)

                    if fit_real != [] and fit_imag != []:
                        fitted_spectrum.real = fit_real[-1]
                        fitted_spectrum.imag = - fit_imag[-1]
                        
                        fitted_interf = transform_spectrum(
                            fitted_spectrum, nm_laser, nm_laser,
                            step, order, None, zpd_shift,
                            ext_phase=ext_phase,
                            return_complex=True)
                        
                        noise_interf = interf2 / fitted_interf
                    
                        noise_cube_col[ij,:] = noise_interf
                
                        
            return noise_cube_col


        SIGMA_CUT_COEFF = 2.5 # Coefficient for the sigma cut to
                              # reject bad values before computing
                              # noise vector

        self._print_msg("Computing noise cube", color=True)
        
        # define range
        if x_range == None:
            x_min = 0
            x_max = self.dimx
        else:
            x_min = np.min(x_range)
            x_max = np.max(x_range)
            
        if y_range == None:
            y_min = 0
            y_max = self.dimy
        else:
            y_min = np.min(y_range)
            y_max = np.max(y_range)

        # load data
        interf_cube = np.zeros((x_max - x_min, y_max - y_min, self.dimz),
                               dtype=complex)
        
        if use_defringed_interf:
            interf_cube.real = self.read_fits(self.get_corrected_cube_path(
                real=True, spectrum=False, defringed=True))
            interf_cube.imag = self.read_fits(self.get_corrected_cube_path(
                real=False, spectrum=False, defringed=True))
            apod = None
        else:
            interf_cube.real = self.cube[x_min:x_max, y_min:y_max,:]
            apod = self.apod

        # create noise cube
        noise_cube = np.empty_like(interf_cube, dtype=complex)

        job_server, ncpus = self._init_pp_server()
        progress = ProgressBar(x_max - x_min)
        for ii in range(0, x_max - x_min, ncpus):
            progress.update(ii, info='Computing noise cube')
            # no more jobs than frames to compute
            if (ii + ncpus >= x_max - x_min):
                ncpus = x_max - x_min - ii

            jobs = [(ijob, job_server.submit(
                _compute_noise_in_column, 
                args=(interf_cube[ii+ijob,:,:],
                      self.phase_map[x_min+ii+ijob,y_min:y_max],
                      self.phase_coeff_1, self.nm_laser,
                      self.calib_map[x_min+ii+ijob,y_min:y_max],
                      self.step, self.order, self.zpd_shift, self.apod,
                      self.lines + self.lines_shift),
                modules=("numpy as np", "from orcs.utils import *"))) 
                    for ijob in range(ncpus)]

            for ijob, job in jobs:
                noise_cube[ii+ijob,:,:] = job()
     
        progress.end()

        # write down noise cube
        self.write_fits(self.get_noise_cube_path(real=True),
                        noise_cube.real, overwrite=self.overwrite)
        self.write_fits(self.get_noise_cube_path(real=False),
                        noise_cube.imag, overwrite=self.overwrite)

        self._print_msg("Computing noise vector", color=True)
         
        # compute noise vector
        noise_vector = np.empty(self.dimz, dtype=complex)
        progress = ProgressBar(self.dimz)
        for ik in range(self.dimz):
            progress.update(ik, 'Computing noise vector')
            noise_vector.real[ik] = robust_mean(
                sigmacut(noise_cube[:,:,ik].real,
                         sigma=SIGMA_CUT_COEFF, central_value=None))
            noise_vector.imag[ik] = robust_mean(
                sigmacut(noise_cube[:,:,ik].imag,
                         sigma=SIGMA_CUT_COEFF, central_value=None))
        progress.end()
        
        self.write_fits(self.get_noise_vector_path(real=True),
                        noise_vector.real, overwrite=self.overwrite)
        self.write_fits(self.get_noise_vector_path(real=False),
                        noise_vector.imag, overwrite=self.overwrite)

    def denoise_data(self, x_range=None, y_range=None,
                           return_spectrum=True, use_defringed_interf=False,
                           local=False):

        def _denoise_data_in_column(interf_cube_col, noise_vector_col,
                                    phase_map_col,
                                    phase_coeff_1, nm_laser, calib_map_col,
                                    step, order, zpd_shift, apod,
                                    return_spectrum):

            dimy = interf_cube_col.shape[0]
            dimz = interf_cube_col.shape[1]
            corr_data_cube_col = np.empty_like(interf_cube_col,
                                               dtype=complex)

            for ij in range(dimy):
                # define phase
                coeffs_list = [phase_map_col[ij],
                               phase_coeff_1]
                ext_phase = np.polynomial.polynomial.polyval(
                    np.arange(dimz), coeffs_list)
                
                interf = interf_cube_col[ij,:]

                spectrum = transform_interferogram(
                    interf, nm_laser, calib_map_col[ij],
                    step, order, apod, zpd_shift,
                    ext_phase=ext_phase,
                    return_complex=True)

                interf2 = transform_spectrum(
                    spectrum, nm_laser, calib_map_col[ij],
                    step, order, None, zpd_shift,
                    ext_phase=ext_phase,
                    return_complex=True)
  
                interf_corr = interf2 / noise_vector_col[ij,:]
             
                if return_spectrum:
                    spectrum_corr = transform_interferogram(
                        interf_corr, nm_laser, calib_map_col[ij],
                        step, order, None, zpd_shift,
                        ext_phase=ext_phase, n_phase=None,
                        return_complex=True)

                    corr_data_cube_col[ij,:] = spectrum_corr
                else:
                    corr_data_cube_col[ij,:] = interf_corr

            return corr_data_cube_col

        LOCAL_BOX_SIZE = 20 # Box size used for local correction
        SIGMA_CUT_COEFF = 3.
        
        self._print_msg("Correcting data", color=True)
        
        # define range
        if x_range == None:
            x_min = 0
            x_max = self.dimx
        else:
            x_min = np.min(x_range)
            x_max = np.max(x_range)
            
        if y_range == None:
            y_min = 0
            y_max = self.dimy
        else:
            y_min = np.min(y_range)
            y_max = np.max(y_range)

        if not local:
            # load noise vector
            noise_vector = np.empty(self.dimz, dtype=complex)
            noise_vector.real = self.read_fits(
                self.get_noise_vector_path(real=True))
            noise_vector.imag = self.read_fits(
                self.get_noise_vector_path(real=False))
        else:
            self._print_msg('Recomputing noise cube')
            # load noise cube
            noise_cube = np.empty((x_max - x_min, y_max - y_min, self.dimz),
                                  dtype=complex)
            local_noise_cube = np.empty_like(noise_cube)
            
            noise_cube.real = self.read_fits(
                self.get_noise_cube_path(real=True))
            noise_cube.imag = self.read_fits(
                self.get_noise_cube_path(real=False))

            progress = ProgressBar(x_max - x_min)
            for ii in range(x_max-x_min):
                progress.update(ii)
                for ij in range(y_max-y_min):
                    (x_min_box, x_max_box,
                     y_min_box, y_max_box) = get_box_coords(
                        ii, ij, LOCAL_BOX_SIZE, 0, x_max-x_min, 0, y_max-y_min)
                    noise_sub_cube = noise_cube[x_min_box:x_max_box,
                                                y_min_box:y_max_box, :]
                    local_noise_cube[ii,ij,:] = np.median(np.median(noise_sub_cube, axis=0), axis=0)
                    
                    ## for ik in range(self.dimz):
                    ##     local_noise_cube.real[ii,ij,ik] = robust_mean(
                    ##         sigmacut(noise_sub_cube[:,:,ik].real,
                    ##                  sigma=SIGMA_CUT_COEFF, central_value=None))
                    ##     local_noise_cube.imag[ii,ij,ik] = robust_mean(
                    ##         sigmacut(noise_sub_cube[:,:,ik].imag,
                    ##                  sigma=SIGMA_CUT_COEFF, central_value=None))
            progress.end()
            del noise_cube
            
        # load data
        interf_cube = np.zeros((x_max - x_min, y_max - y_min, self.dimz),
                               dtype=complex)
        if use_defringed_interf:
            interf_cube.real = self.read_fits(self.get_corrected_cube_path(
                real=True, spectrum=False, defringed=True))
            interf_cube.imag = self.read_fits(self.get_corrected_cube_path(
                real=False, spectrum=False, defringed=True))
            apod = self.apod
        else:
            interf_cube.real = self.cube[x_min:x_max, y_min:y_max,:]
            apod = self.apod

        # correct data
        corr_data_cube = np.empty_like(interf_cube, dtype=complex)
        job_server, ncpus = self._init_pp_server()
        progress = ProgressBar(x_max - x_min)
        for ii in range(0, x_max - x_min, ncpus):
            progress.update(ii, info='Correcting data')
            # no more jobs than frames to compute
            if (ii + ncpus >= x_max - x_min):
                ncpus = x_max - x_min - ii

            if not local:
                noise_vector_col = np.zeros((ncpus, y_max-y_min, self.dimz), dtype=complex)
                noise_vector_col += noise_vector
            else:
                noise_vector_col = local_noise_cube[ii:ii+ncpus,:,:]
                
            jobs = [(ijob, job_server.submit(
                _denoise_data_in_column, 
                args=(interf_cube[ii+ijob,:,:],
                      noise_vector_col[ijob,:,:],
                      self.phase_map[x_min+ii+ijob,y_min:y_max],
                      self.phase_coeff_1, self.nm_laser,
                      self.calib_map[x_min+ii+ijob,y_min:y_max],
                      self.step, self.order, self.zpd_shift, apod,
                      return_spectrum),
                modules=("numpy as np", "from orcs.utils import *"))) 
                    for ijob in range(ncpus)]

            for ijob, job in jobs:
                corr_data_cube[ii+ijob,:,:] = job()
     
        progress.end()

        # write down corrected data
        self.write_fits(self.get_corrected_cube_path(
            real=True, spectrum=return_spectrum),
                        corr_data_cube.real, overwrite=self.overwrite,
                        fits_header=self.fits_hdr)
        self.write_fits(self.get_corrected_cube_path(
            real=False, spectrum=return_spectrum),
                        corr_data_cube.imag, overwrite=self.overwrite,
                        fits_header=self.fits_hdr)


    def remove_fringes(self, frequency, amplitude, x_range=None, y_range=None,
                       use_corrected_interf=False, return_spectrum=False):

        def _remove_fringes_in_column(interf_cube_col, frequency, amplitude,
                                      phase_map_col, phase_coeff_1,
                                      nm_laser, calib_map_col,
                                      step, order, zpd_shift, apod,
                                      return_spectrum):
            dimy = interf_cube_col.shape[0]
            dimz = interf_cube_col.shape[1]
            corr_data_cube_col = np.empty_like(interf_cube_col,
                                               dtype=complex)

            for ij in range(dimy):
                # define phase
                coeffs_list = [phase_map_col[ij],
                               phase_coeff_1]
                ext_phase = np.polynomial.polynomial.polyval(
                    np.arange(dimz), coeffs_list)

                interf = interf_cube_col[ij,:]
                
                for inoise in range(len(frequency)):
                    noise_vector = variable_me(
                        dimz, [frequency[inoise],
                               amplitude[inoise], 0.])

                    interf = interf / noise_vector
                

                if return_spectrum:
                    corr_spectrum = transform_interferogram(
                        interf, nm_laser, calib_map_col[ij],
                        step, order, apod, zpd_shift,
                        ext_phase=ext_phase, n_phase=None,
                        return_complex=True)

                    corr_data_cube_col[ij,:] = corr_spectrum
                else:
                    corr_data_cube_col[ij,:] = interf

            return corr_data_cube_col

        self._print_msg("Correcting fringes", color=True)
        
        # define range
        if x_range == None:
            x_min = 0
            x_max = self.dimx
        else:
            x_min = np.min(x_range)
            x_max = np.max(x_range)
            
        if y_range == None:
            y_min = 0
            y_max = self.dimy
        else:
            y_min = np.min(y_range)
            y_max = np.max(y_range)


        # check frequency and amplitude
        frequency = list(frequency)
        amplitude = list(amplitude)
        if len(frequency) != len(amplitude):
            self._print_error('frequencies and amplitudes must have the same length')

        interf_cube = np.zeros((x_max - x_min, y_max - y_min, self.dimz),
                               dtype=complex)
         # load data
        if use_corrected_interf:
            interf_cube.real = self.read_fits(self.get_corrected_cube_path(
                real=True, spectrum=False))
            interf_cube.imag = self.read_fits(self.get_corrected_cube_path(
                real=False, spectrum=False))
            apod = None
        else:
            interf_cube.real = self.cube[x_min:x_max, y_min:y_max,:]
            apod = self.apod
            
        # correct data
        corr_data_cube = np.empty_like(interf_cube, dtype=complex)
        job_server, ncpus = self._init_pp_server()
        progress = ProgressBar(x_max - x_min)
        for ii in range(0, x_max - x_min, ncpus):
            progress.update(ii, info='Correcting fringes')
            # no more jobs than frames to compute
            if (ii + ncpus >= x_max - x_min):
                ncpus = x_max - x_min - ii

            jobs = [(ijob, job_server.submit(
                _remove_fringes_in_column, 
                args=(interf_cube[ii+ijob,:,:], frequency, amplitude,
                      self.phase_map[x_min+ii+ijob,y_min:y_max],
                      self.phase_coeff_1, self.nm_laser,
                      self.calib_map[x_min+ii+ijob,y_min:y_max],
                      self.step, self.order, self.zpd_shift, apod,
                      return_spectrum),
                modules=("numpy as np", "from orcs.utils import *"))) 
                    for ijob in range(ncpus)]

            for ijob, job in jobs:
                corr_data_cube[ii+ijob,:,:] = job()
                
        progress.end()
                
        # write down corrected data
        self.write_fits(self.get_corrected_cube_path(
            real=True, spectrum=return_spectrum, defringed=True),
                        corr_data_cube.real[:,:,:], overwrite=self.overwrite,
                        fits_header=None)#self.fits_hdr)
        self.write_fits(self.get_corrected_cube_path(
            real=False, spectrum=return_spectrum, defringed=True),
                        corr_data_cube.imag[:,:,:], overwrite=self.overwrite,
                        fits_header=None)#self.fits_hdr)

