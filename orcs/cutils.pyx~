# cython: embedsignature=True
# *-* coding: utf-8 *-*
# Author: Thomas Martin <thomas.martin.1@ulaval.ca>
# File: cutils.pyx


# __author__ = "Thomas Martin"
# __licence__ = "Thomas Martin (thomas.martin.1@ulaval.ca)"
# __docformat__ = 'reStructuredText'

"""
CUtils is a set of C functions for ORCS coded in Cython_ to improve their speed.

.. note:: This file must be compiled before it can be used in ORCS::

     cython cutils.pyx
     
     gcc -c -fPIC -I/usr/include/python2.7 cutils.c
     
     gcc -shared cutils.o -o cutils.so

.. _Cython: http://cython.org/

"""
from core import *
from cutils import *

import numpy as np
cimport numpy as np
import scipy.ndimage.filters

import bottleneck as bn # https://pypi.python.org/pypi/Bottleneck
from cpython cimport bool

## Import functions from math.h (faster than python math.py)
cdef extern from "math.h":
    double cos(double theta)
    double sin(double theta)
    double exp(double x)
    double sqrt(double x)
    double log(double x)
    double ceil(double x)
    double floor(double x)
    double M_PI


def cpart_value(np.ndarray[np.float64_t, ndim=1] distrib, double coeff):
    """Return the value lying between two parts of a partition 

    The partition process is nan robusts. It is made over a
    distribution cleaned from nans.
    
    :param distrib: A 1D array of floats.
    
    :param coeff: Partition coefficient (must be >= 0. and <= 1.). If
      0 return the min of the distribution and if 1 return the max.
    """
    cdef np.ndarray[np.float64_t, ndim=1] cleaned_distrib = distrib[
        np.nonzero(~np.isnan(distrib))]
    cdef int k

    coeff = max(0., min(1., coeff)) # coeff is coerced between 0 and 1
    
    if coeff == 0:
        return np.nanmin(distrib)
    if coeff == 1:
        return np.nanmax(distrib)
    
    k = (min(<int> (coeff * np.size(cleaned_distrib)),
             np.size(cleaned_distrib) - 1))
    return np.partition(cleaned_distrib, k)[k]

def csnr_smooth(np.ndarray[np.float64_t, ndim=2] im,
                np.ndarray[np.float64_t, ndim=2] snr_im,
                np.ndarray[np.uint8_t, ndim=2, cast=True] mask,
                double smooth_power, double clip_coeff=0.9999,
                double scaling_power=2.):

    """
    Smooth an image by SNR using a median smoothing function.

    :param im: Image to smooth

    :param snr_im: SNR image. Must have the same shape as th input
      image.
    
    :param smooth_power: Smoothing power. Must be between 0. and 1.

    :param clip_coeff: (Optional) ratios of values used to establish
      the scale. A ratio 0.9999 means that the 0.01 % of the highest
      and lowest values are ot taken into account (default 0.9999).

    :param scaling_power: (Optional) scaling power. When high the lowest
      values are smoothed a lot more than the higher values (default
      2.)
    """
    cdef np.ndarray[np.float64_t, ndim=2] final_im = np.empty_like(im)
    cdef int iscale, ipix
    cdef int x_min, x_max, y_min, y_max
    cdef int ix, iy
    cdef int deg
    # DEG MAX is coerced to be between 4 and im.shape/10 and smooth
    # power is coerced between 0 and 1. IF DEG MAX = 0, no smooth is
    # done !
    cdef int DEG_MAX = <int> max((min(im.shape[0], im.shape[1]) / 10.
                                  * max(0., min(smooth_power, 1.))), 4)
    
    cdef double snr_max = cpart_value(snr_im.flatten(), clip_coeff)
    cdef double snr_min = cpart_value(snr_im.flatten(), 1.-clip_coeff)
    cdef np.ndarray[np.float64_t, ndim=1] snr_scale = (
        np.linspace(snr_min, snr_max, DEG_MAX + 1))
    cdef np.ndarray[np.float64_t, ndim=1] deg_scale = (
        (np.arange(DEG_MAX, dtype=float)**scaling_power))
    cdef double MAX_NANS = 0.5
    
    deg_scale /= np.max(deg_scale) / DEG_MAX

    snr_scale[0] = np.nanmin(snr_im)
    snr_scale[-1] = np.nanmax(snr_im)
    
    if DEG_MAX == 0:
        return im
    
    if np.any(np.isinf(im)):
        im[np.nonzero(np.isinf(im))] = np.nan        
    
    final_im = np.copy(im)

    snr_im[np.nonzero(np.isnan(snr_im))] = np.nanmin(snr_im)

    for iscale in range(DEG_MAX):
        pixs = np.nonzero((snr_im >= snr_scale[DEG_MAX-iscale-2])
                          * (snr_im < snr_scale[DEG_MAX-iscale-1]))
        
        for ipix in range(len(pixs[0])):
            ix = pixs[0][ipix]
            iy = pixs[1][ipix]
            if not mask[ix, iy]:
                x_min, x_max, y_min, y_max = cget_box_coords(
                    ix, iy, int(deg_scale[iscale]) * 2 + 1,
                    0, im.shape[0], 0, im.shape[1])
                if np.sum(np.isnan(im[x_min:x_max, y_min:y_max])) < MAX_NANS * np.size(im[x_min:x_max, y_min:y_max]):
                    final_im[ix,iy] = bn.nanmedian(im[x_min:x_max, y_min:y_max])
            else:
                final_im[ix,iy] = np.nan
            
    return final_im
    

