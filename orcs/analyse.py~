#!/usr/bin/python
# *-* coding: utf-8 *-*
# Author: Thomas Martin <thomas.martin.1@ulaval.ca>
# File: analyse.py

"""
Analysis module for ORCS

.. note:: ORCS is built over ORBS so that ORBS must be
  installed. Please make sure to give ORCS the correct path to ORBS
  files
"""

from core import *
from utils import *
from orcs import *

import pylab as pl
import matplotlib.cm as cm
import matplotlib.colors as colors

# PyNeb: Luridiana, Morisset, & Shaw, 2012, IAU Symposium 283, 422-423
#import pyneb as pn

class Maps(ORCSTools):

    cubemaps = list()
    deep_frames = list()
    shifts = list()

    snr_limit = None
    ext_law = None # Extinction law
    cHbeta = None # Extinction map
    snr_smooth_limits = None

    nscalib = None
    ZO = None
    ZN = None
    nSII = None
    
    def __init__(self, option_file_paths, object_name=None, ovserwrite=True,
                 snr_limit=0., overwrite=True, shifts=None, ext_law='CCM 89',
                 snr_smooth_limits=None):

        self.option_file_paths = option_file_paths
        self.snr_limit = snr_limit
        self.overwrite = overwrite
        self.ext_law = ext_law
        if snr_smooth_limits != None:
            self.snr_smooth_limits = snr_smooth_limits
        else:
            self.snr_smooth_limits = np.zeros(len(self.option_file_paths))
        
        # load CubeMaps
        self._load_cubemaps()

        # Compute shift
        self._print_msg('Computing shifts', color=True)
        
        if shifts == None:
            self.shifts.append(None)
            sc = SpectralCube(self.option_file_paths[0], overwrite=True)
            self.deep_frames.append(sc.create_deep_frame(write=False))
            for icubemap in range(1, len(self.cubemaps)):
                sc = SpectralCube(self.option_file_paths[icubemap],
                                  overwrite=True)
                self.deep_frames.append(sc.create_deep_frame(write=False))
                self.shifts.append(
                    get_image_shift(self.deep_frames[0],
                                    self.deep_frames[icubemap]))
                
        elif len(shifts) == len(option_file_paths):
            self.shifts = shifts

        else:
            self._print_error(
                'shifts must be a tuple of the same size as option_file_paths')
            
       
        self._print_msg('Shifts : %s'%str(self.shifts))

        # reload maps with shifts
        self._load_cubemaps()

    def _load_cubemaps(self):
        self.cubemaps = list()
        
        for iopt in range(len(self.option_file_paths)):
            if self.shifts == []:
                shift = None
            else:
                shift = self.shifts[iopt]
                
            self.cubemaps.append(CubeMaps(
                self.option_file_paths[iopt],
                snr_limit=self.snr_limit,
                overwrite=self.overwrite,
                shift=shift,
                cHbeta=self.cHbeta,
                ext_law=self.ext_law,
                snr_smooth_limit=self.snr_smooth_limits[iopt]))


    def get_map(self, line, param='FLUX'):
        for icubemap in self.cubemaps:
            if int(line) in icubemap.lines_list:
                return icubemap.get_map(line, param=param)
                
        self._print_error('Line %f is not recorded'%line)
        
    def get_header(self, line, file_type, comment=None):
        hdr = self.get_map(line).header
        if comment == None:
            hdr['FILETYPE'] = file_type
        else:
            hdr['FILETYPE'] = (file_type, str(comment))
        return hdr
    
    def get_cHbeta(self):
        """c(Hbeta) is computed from the Ha/Hb ratio and Storey Hummer tables
        """
        self._print_msg('Computing c(Hbeta)', color=True)
        ha = self.get_map(6563)
        hb = self.get_map(4861)
        
        th_ratio = BalmerTable(case='B').get_ratio(te=1e4, ne=1000, nu=3)
        re_ratio = ha.get_data()/hb.get_data()
        
        rc = pn.RedCorr(law=self.ext_law)
        rc.setCorr(re_ratio/th_ratio, 6563., 4861.)
        
        self.cHbeta = Map(rc.cHbeta)
        self.cHbeta.header = self.get_header(6563, 'C(Hbeta) Map')
        
        # reload corrected maps 
        self._load_cubemaps()
        return self.cHbeta

    def get_sii_density_map(self, tem, x_range=[], y_range=[]):

        """Return density map from SII lines ratio.

        Density is computed by the method pyneb.Atom.getTemDen from
        the PyNeb module (Luridiana, Morisset, & Shaw, 2012, IAU
        Symposium 283, 422-423).
        """
        def compute_density_in_column(sii_ratio_column, tem):
            # NaNs are removed before density computation
            nans = np.nonzero(np.isnan(sii_ratio_column))
            sii_ratio_column[nans] = 1. 
            sii_density_column = pn.Atom('S',2).getTemDen(
                np.squeeze(sii_ratio_column), tem=tem,
                wave1=6716, wave2=6731)
            # Nans are replaced after
            sii_density_column[nans] = np.nan
            return sii_density_column

        self._print_msg('Computing n(SII)', color=True)

        if x_range == []:
            x_min = 0
            x_max = self.dimx
        else:
            x_min = min(x_range)
            x_max = max(x_range)

        if y_range == []:
            y_min = 0
            y_max = self.dimy
        else:
            y_min = min(y_range)
            y_max = max(y_range)
            
        sii1 = self.get_map(6716)
        sii2 = self.get_map(6731)
        
        sii_ratio = sii1.get_data() / sii2.get_data()

        sii_density = np.empty_like(sii_ratio)
        sii_density.fill(np.nan)

        job_server, ncpus = self._init_pp_server()
        progress = ProgressBar(x_max-x_min)
        
        for icol in range(x_min, x_max, ncpus):
            progress.update(icol-x_min, info="Computing density")

            if icol + ncpus >= x_max:
                ncpus = x_max - icol

            jobs = [(ijob, job_server.submit(
                compute_density_in_column, 
                args=(np.copy(sii_ratio[icol + ijob,y_min:y_max]), tem),
                modules=("import numpy as np",
                         "import pyneb as pn")))
                    for ijob in range(ncpus)]

            for ijob, job in jobs:
                sii_density[icol + ijob,y_min:y_max] = job()

        self._close_pp_server(job_server)
        progress.end()
        
        self.nSII = Map(sii_density)
        self.nSII.header = self.get_header(6563, 'n(SII) Map')
        return self.nSII


    def get_ZO(self):
        if self.nscalib == None:
            self.nscalib = NSCalibration(self)
        return self.nscalib.get_ZO()
        
    def get_ZN(self):
        if self.nscalib == None:
            self.nscalib = NSCalibration(self)
        return self.nscalib.get_ZN()

    def get_t2(self):
        if self.nscalib == None:
            self.nscalib = NSCalibration(self)
        return self.nscalib.get_t2()
        

#################################################
#### CLASS CubeMaps #############################
#################################################
class CubeMaps(ORCSTools):

    maps_list = None
    params_list = None
    lines_list = None

    dimx = None
    dimy = None
    
    overwrite = None

    object_name = None

    noise_map = None
    snr_limit = None

    def __init__(self, option_file_path, snr_limit=0.,
                 shift=None, cHbeta=None, ext_law=None, snr_smooth_limit=None,
                 silent=True, cube_path=None,
                 object_name=None, overwrite=True):
        """
        :param snr_limit: (Optional) The SNR limit is the minimum
            Signal/Noise Ratio of the amplitude of an emission line
            for its parameters to be considered as good (Default 5.).

        :param snr_smooth_limit: (Optional) SNR smoothing limit (default 0)

        :param ext_law: (Optional) Extinction law. See pyneb.RedCorr
          for more informations about the available extinction laws.

        :param cHbeta: (Optional) C(Hbeta) map to correct returned map
            for reddening.
        """
        # Load options file
        self.options = OptionFile(option_file_path)
        
        if cube_path == None:
            self.cube_path = self.options["CUBE_PATH"]
        else: self.cube_path = cube_path

        cube_hdu = self.read_fits(self.cube_path, return_hdu_only=True)

        # Define object name
        if object_name == None:
            self.object_name = cube_hdu[0].header['OBJECT']
        else:
            self.object_name = object_name

        # Get maps list path
        sc =  SpectralCube(option_file_path, no_data_load=True)
        maps_list_path = sc._get_maps_list_path()

        self.snr_limit = snr_limit
        
        # Load Maps
        self.maps_list = list()
        self.params_list = list()
        self.lines_list = list()
        maps_file = self.open_file(maps_list_path, 'r')
        for iline in maps_file:
            iline = iline.split()
            imap = Map(iline[0], wave=int(iline[1]),
                       param=iline[2], shift=shift, cHbeta=cHbeta,
                       ext_law=ext_law, snr_smooth_limit=snr_smooth_limit,
                       snr_limit=snr_limit)
            self.maps_list.append(imap)
            
            if int(imap.wave) not in self.lines_list:
                self.lines_list.append(int(imap.wave))
                
            if imap.param not in self.params_list:
                self.params_list.append(imap.param)
                
            if len(self.maps_list) == 1:
                self.dimx = self.maps_list[0].dimx
                self.dimy = self.maps_list[0].dimy
                if not silent:
                    self._print_msg("Maps shape: (%d, %d)"%(
                        self.dimx, self.dimy))
            elif ((self.maps_list[-1].dimx != self.dimx)
                  or (self.maps_list[-1].dimy != self.dimy)):
                self._print_error("Maps shape are not the same. Please check maps folder")

        # load SNR maps
        for imap in self.maps_list:
            imap.load_snr_map(self.get_map(imap.wave, 'SNR'))
            
        if not silent:    
            self._print_msg("Extracted lines: %s"%str(self.lines_list))
            self._print_msg("Fit parameters: %s"%str(self.params_list))
        self.filter_name = cube_hdu[0].header['FILTER']

        self.params_list.append('FLUX')
        self._data_prefix = self._get_data_prefix(self.object_name)
        self._data_path_hdr = self._get_data_path_hdr()
        self.overwrite = overwrite
    
    def _get_data_prefix(self, object_name):
        return (os.curdir + os.sep + object_name + '_'
                + self.filter_name  + os.sep + object_name + '_')

    def _get_mask_path(self):
        """Return path to a mask frame"""
        return self._data_path_hdr + "mask.fits"
        
    def _get_processed_map_path(self, line0, line1, operation,
                                info=None):
        """Return path to the result of a operation (e.g. divide, mean)

        :param info: (Optional) Must be a list a string or a list of
          strings to be appended to the name of the file.
        """
        if info != None:
            if isinstance(info, (list, tuple)):
                info = '_'.join(info)
            else:
                info = str(info)
        else:
            info = ''

        if line0 != '':
            if isinstance(line0, (list, tuple)):
                line0 =[str(iline) for iline in line0]
                name_line_0 = '+'.join(line0)
            else:
                name_line_0 = str(line0)
            name_line_0 += '_'
        else:
            name_line_0 = ''

        if line1 != '':
            if isinstance(line1, (list, tuple)):
                line1 =[str(iline) for iline in line1]
                name_line_1 = '+'.join(line1)
            else:
                name_line_1 = str(line1)
            name_line_1 += '_'
        else:
            name_line_1 = ''

        name = '%s%s%s'%(name_line_0, name_line_1, info)
        
        return self._data_path_hdr + "%s_%s.fits"%(operation, name)

    def _get_header(self, file_type, comment=None):
        hdr = self.maps_list[0].header
        if comment == None:
            hdr['FILETYPE'] = file_type
        else:
            hdr['FILETYPE'] = (file_type, str(comment))
        return hdr

    def _get_mask_from_masks(self, mask_path):
        """Return a mask from a tuple of masks paths.

        :param mask_path: Tuple of paths to mask-like frames. It can
          be a simple string.
        """
        if isinstance(mask_path, (list, tuple)):
            mask_list = [self.read_fits(imask_path)
                         for imask_path in mask_path]
            mask = np.array(mask_list)
            mask = np.all(mask, axis=0)
        elif isinstance(mask_path, (basestring)):
            mask = self.read_fits(mask_path)
        else:
            self._print_error('mask_path must be a string or a list of strings')
        return mask
            
	
    def get_map(self, line, param='FLUX', return_data=False):
        """Return map data.

        :param line: Line number (a 4 digit wavelength in angstrom) of
          the map or line name.

        :param param: Parameter of the map.

        :param return_data: (Optional) If True, only map data is
          returned. Else an orcs.core.Map instance is returned
          (default False).
        """
        if isinstance(line, str):
            line = self.get_line_nm(line, round_ang=True)

        if line in self.lines_list:
            if param in self.params_list:
                if param != 'FLUX':
                    _map = [imap for imap in self.maps_list
                            if ((imap.wave == line)
                                and (imap.param == param))]
                    _map = _map[0]

                    
                else:
                    _map = self.get_map(line, param='AMP')
                    _map_fwhm = self.get_map(line, param='FWHM')
                    _map.data *= _map_fwhm.data * math.sqrt(2.*math.pi)
                    _map.param = 'FLUX'
                    _map.header['FILETYPE'] = 'Flux Map %d'%_map.wave
              
                # return map
                if return_data: return np.copy(_map.get_data())
                else: return _map.copy() # instance copy is very important !

            else:
                self._print_error(
                    'param must be in %s'%str(self.params_list))
        else:
            self._print_error(
                'line (%d) must be in %s'%(line, str(self.lines_list)))


    def create_mask_from_regions(self, regions_file_path, positive=True):
        mask = np.zeros((self.dimx, self.dimy))
        regions = self.get_mask_from_ds9_region_file(regions_file_path,
                                                     x_range=[0, self.dimx],
                                                     y_range=[0, self.dimy])
        mask[regions] = 1.
        if not positive:
            mask = -mask + 1
        self.write_fits(self._get_mask_path(), mask,
                        overwrite=self.overwrite,
                        fits_header=self._get_header('Mask Map'))
        return mask


    def mean(self, lines, param='AMP', mask_path=None, snr_limit=None):
        """
        :param snr_limit: (Optional) If given, replace the SNR limit
          of the class. The SNR limit is the minimum Signal/Noise
          Ratio of the amplitude of an emission line for its
          parameters can be considered as good.
        """
        mean_map = self.get_map(lines[0], param=param, snr_limit=snr_limit)
        count_map = np.zeros_like(mean_map)
        count_map[np.nonzero(mean_map != np.nan)] = 1
        for iline in lines:
            imap = self.get_map(iline, param=param, snr_limit=snr_limit)
            nan_mask = np.ones
            nan_mask = np.nonzero(imap == np.nan)
            nonans = np.nonzero(imap != np.nan)
            imap[np.nonzero(imap == np.nan)] = 0.
            mean_map += imap
            count_map[np.nonzero(imap != np.nan)] += 1
            
        # filter bad pixels
        if mask_path != None:
            # filter bad pixels
            mask = self._get_mask_from_masks(mask_path)
            mean_map *= mask
            
        mean_map[np.nonzero(mean_map == 0)] = np.nan

        mean_map /= count_map

        info = list()
        info.append(param)
        
        self.write_fits(
            self._get_processed_map_path(lines, '', 'mean', info=info),
            mean_map,
            overwrite=self.overwrite,
            fits_header=self._get_header('Mean Map %s'%str(lines),
                                         comment=' '.join(info)))
        
        return mean_map

    def divide(self, line0, line1, param='FLUX', mask_path=None,
               replace_value=np.nan, smooth_deg=0, log10=False,
               mean=False, snr_limit=None, snr_filter=True):
        """Divide the map corresponding to the line0 by the map
        corresponding to the line1.

        :param line0: Line of the map considered as the numerator. It
          can be a tuple. In this case maps corresponding to each line
          are summed.

        :param line1: Line of the map considered as the
          denominator. It can be a tuple. In this case maps
          corresponding to each line are summed.

        :param param: (Optional) Choose the parameter of the maps to
          be divided (Default 'FLUX')

        :param mask_path: (Optional) Path to a mask-like frame to
          remove 'bad' pixels from the computation. In the mask 'bad'
          pixels are zeros and 'object' pixels are ones (default
          None). Can be a list of paths. In this case masks are summed
          with a logical AND (bad pixels are kept everywhere). Bad
          pixels are replaced by NaN.

        :param replace_value: (Optional) Replacement value for bad
          pixels (zeros, or sky pixels) (default np.nan, a NaN
          value)

        :param smooth_deg: (Optional) If > 0 the resulting map is
          smoothed by a gaussian kernel of degree smooth_deg (default 0.)

        :param log10: (Optional) Return the log10 of the result
          (default False).

        :param mean: (Optional) If True, the mean of the maps in
          tuples are taken instead of their sum (default False).

        :param snr_limit: (Optional) If given, replace the SNR limit
          of the class. The SNR limit is the minimum Signal/Noise
          Ratio of the amplitude of an emission line for its
          parameters can be considered as good.

        :param snr_filter: (Optional) If True, map is filtered by
          SNR. If False, map is returned as it is (default True).
        
        .. note:: zero pixels are considered as bad and replaced by a
          zero in the resulting frame
        """

        def sum_line_list(line, mean, param, snr_limit, snr_filter):
            map_cube = self.get_map(line[0], param=param,
                                    snr_limit=snr_limit,
                                    snr_filter=snr_filter)
            
            for imap in range(1, len(line)):
                map_cube = np.dstack(
                        (map_cube, self.get_map(line[imap], param=param,
                                                snr_limit=snr_limit,
                                                snr_filter=snr_filter)))
            if mean:
                return np.mean(map_cube, axis=2)
            else:
                return np.sum(map_cube, axis=2)

        # summing maps if they are tuple
        if isinstance(line0, (list, tuple)):
            map0 = sum_line_list(line0, mean, param, snr_limit,
                                 snr_filter)
        else:
            map0 = self.get_map(line0, param=param, snr_limit=snr_limit,
                                snr_filter=snr_filter)
            
        if isinstance(line1, (list, tuple)):
            map1 = sum_line_list(line1, mean, param, snr_limit,
                                 snr_filter)
        else:
            map1 = self.get_map(line1, param=param, snr_limit=snr_limit,
                                snr_filter=snr_filter)

        # filter bad pixels
        if mask_path != None:
            mask = self._get_mask_from_masks(mask_path)
            map0 *= mask
            map1 *= mask
        
        # creating mask to remove zeros from calculation
        mask = np.zeros_like(map0, dtype=int)
        mask[np.nonzero(map0 == 0)] = 1
        mask[np.nonzero(map1 == 0)] = 1
        mask = np.nonzero(mask)
        map0[mask] = 0.
        map1[mask] = 1. # avoid dividing by zero
        result = map0 / map1
        result[mask] = replace_value
        

        info = list()
        info.append(param)
        
        if smooth_deg > 0:
            result = low_pass_image_filter(result, smooth_deg)
            info.append('smoothed%d'%smooth_deg)
            
        if log10:
            result = np.log10(result)
            info.append('log10')

        # Save result
        self.write_fits(
            self._get_processed_map_path(line0, line1, 'divide', info=info),
            result,
            overwrite=self.overwrite,
            fits_header=self._get_header('Division Map %s/%s'%(line0, line1),
                                         comment=' '.join(info)))

        return result

    
#################################################
#### CLASS RegionDiagram ########################
#################################################
class RegionDiagram(ORCSTools):


    def __init__(self, option_files_paths, region_files_paths,
                 background_region_files_paths=None, shifts=None):

        self.maps = list()
        self.all_lines = list()
        
        if shifts != None:
            if len(shifts) == len(option_files_paths):
                self.shifts = shifts
            else:
                self._print_error('Given shifts list has not the same number of elements as the option files list')
                
        for iopt in option_files_paths:
            if self.shifts != None:
                shift = [self.shifts[iopt][0], self.shifts[iopt][1]]
            else: shift = None
            self.maps.append(Maps(iopt, shift=shift))
            self.all_lines += self.maps[-1].lines_list
            
        self.regions = list()
        for ireg in region_files_paths:
            self.regions.append([self.get_mask_from_ds9_region_file(ireg),
                                 ireg[:-4]])
                
        if background_region_files_paths != None:
            if len(background_region_files_paths) == len(self.regions):
                self.background_regions = list()
                for ireg in background_region_files_paths:
                    if ireg != '':
                        self.background_regions.append(
                            self.get_mask_from_ds9_region_file(ireg))
                    else:
                        self.background_regions.append([])
            else:
                self._print_error('Given background regions files paths list has not the same number of elements as the region files paths list')
        else:
            self.background_regions = None
            
        self._print_msg("Mapped emission lines: %s"%str(self.all_lines))

        self.colors = colors.normalize(0, len(self.regions))

    def _get_color(self, iregion):
        """Return the color of a region.

        :param iregion: Index of the region
        """
        return cm.jet(self.colors(iregion))

    def get_map(self, line_name, snr_filter=True):
        line = self.get_line_nm(line_name, round_ang=True)
        for im in range(len(self.maps)):
            imap = self.maps[im]
            if line in imap.lines_list:
                _map = imap.get_map(line, snr_filter=snr_filter)
                return _map
        self._print_error(
            '%s line does not appear to be mapped'%str(line_name))

    def plot_bpt(self, snr_filter=True):
        pl.figure('BPT diagram')
        if not np.all([iang in self.all_lines for iang
                       in self.get_line_nm(['[OIII]5007', 'Hbeta',
                                            '[NII]6583', 'Halpha'],
                                           round_ang=True)]):
            self._print_error("Some lines are not mapped. Check presence of [OIII]5007, Hbeta, [NII]6583 and Halpha")
        
        oiii = self.get_map('[OIII]5007', snr_filter=snr_filter)
                #+ self.get_map('[OIII]4959', snr_filter=snr_filter))
        
        nii = self.get_map('[NII]6583', snr_filter=snr_filter)
               #+ self.get_map('[NII]6548', snr_filter=snr_filter))
        
        ha = self.get_map('Halpha', snr_filter=snr_filter)
        hb = self.get_map('Hbeta', snr_filter=snr_filter)
        
        for ireg in range(len(self.regions)):
            nii_reg = nii[self.regions[ireg][0]]
            oiii_reg = oiii[self.regions[ireg][0]]
            ha_reg = ha[self.regions[ireg][0]]
            hb_reg = hb[self.regions[ireg][0]]

            # background correction
            if self.background_regions != None and self.background_regions[ireg] != []:
                
                nii_reg -= robust_mean(sigmacut(
                    nii[self.background_regions[ireg]]))
                oiii_reg -= robust_mean(sigmacut(
                    oiii[self.background_regions[ireg]]))
                ha_reg -= robust_mean(sigmacut(
                    ha[self.background_regions[ireg]]))
                hb_reg -= robust_mean(sigmacut(
                    hb[self.background_regions[ireg]]))

            oiii_hb_reg = np.log10(oiii_reg / hb_reg)
            nii_ha_reg = np.log10(nii_reg / ha_reg)
            
            bpt_arr = np.array([[nii_ha_reg[ipix], oiii_hb_reg[ipix]]
                                for ipix in range(np.size(nii_ha_reg))])

            pl.scatter(bpt_arr[:,0], bpt_arr[:,1], marker='+',
                       color=self._get_color(ireg),
                       label=self.regions[ireg][1],
                       alpha=0.5)


        # plot BPT line from Kewley, Dopita et al. 2001
        x = np.linspace(-4,0.2,1000)
        y = 1.19 + (0.61 / (x - 0.47))
        pl.plot(x,y)

        pl.xlabel(r'[NII]/H$\alpha$')
        pl.ylabel(r'[OIII]/H$\beta$')
        pl.legend()

    def plot_smb(self, snr_filter=True):

        """SMB Diagram from Sabbadin, Minello & Bianchini (1977), A&A, 60.
        """
        pl.figure('SMB diagram')
        if not np.all([iang in self.all_lines for iang
                       in self.get_line_nm(['[NII]6583', 'Halpha', '[SII]6716',
                                            '[SII]6731'],
                                           round_ang=True)]):
            self._print_error("Some lines are not mapped. Check presence of [NII]6583, [SII]6716, [SII]6731 and Halpha")

        nii = (self.get_map('[NII]6583', snr_filter=snr_filter)
               + self.get_map('[NII]6548', snr_filter=snr_filter))
        ha = self.get_map('Halpha', snr_filter=snr_filter)
        sii = (self.get_map('[SII]6716', snr_filter=snr_filter)
               + self.get_map('[SII]6731', snr_filter=snr_filter))
        
        for ireg in range(len(self.regions)):
            nii_reg = nii[self.regions[ireg][0]]
            ha_reg = ha[self.regions[ireg][0]]
            sii_reg = sii[self.regions[ireg][0]]
            
            if self.background_regions != None and self.background_regions[ireg] != []:
                nii_reg -= robust_mean(sigmacut(
                    nii[self.background_regions[ireg]]))
                ha_reg -= robust_mean(sigmacut(
                    ha[self.background_regions[ireg]]))
                sii_reg -= robust_mean(sigmacut(
                    sii[self.background_regions[ireg]]))

            ha_nii_reg = np.log10(ha_reg / nii_reg)
            ha_sii_reg = np.log10(ha_reg / sii_reg)
            
            pl.scatter(ha_sii_reg.flatten(), ha_nii_reg.flatten(), marker='+',
                       color=self._get_color(ireg),
                       label=self.regions[ireg][1],
                       alpha=0.5)

        # Boxes have been taken from Sabin et al. (2013) MNRAS, 431
        
        # SNR box
        SNR_box_x = [-.5, .4, .6, .0, -.5]
        SNR_box_y = [-.6, -.1, .8, .8, -.6]
        pl.plot(SNR_box_x, SNR_box_y)

        # HII Box
        HII_box_x = [.4, 1.3, 2., 2., .95, .7, .6, .4]
        HII_box_y = [-.1, .4, 1.25, 1.5, 1.5, 1.2, .8, -.1]
        pl.plot(HII_box_x, HII_box_y)

        # PN Lines
        PN_line_1_x = [-.5, .7, 1.7]
        PN_line_1_y = [-.4, .5, 1.5]
        PN_line_2_x = [-.1, 1.3, 2.]
        PN_line_2_y = [-1.5, -.5, .1]
        pl.plot(PN_line_1_x, PN_line_1_y)
        pl.plot(PN_line_2_x, PN_line_2_y)

        pl.xlim([-.5, 2.])
        pl.ylim([-1.5, 1.5])
        pl.xlabel(r'H$\alpha/[SII]$')
        pl.ylabel(r'H$\alpha/[NII]$')
        pl.legend()

    def show(self):
        pl.show()


#################################################
#### CLASS BalmerTable ##########################
#################################################
class BalmerTable(Tools):
    
    te_axis = None
    balmer_table = None

    def __init__(self, case='A'):

        # Balmer ratio computed from Storey Hummer (1995) grid files
        # T in K, T can be : 500, 1000, 3000, 5000, 7500, 10000,
        # 12500, 15000, 20000, 30000

        # n in cm-3, n can be : 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8,
        # 1e9, 1e10 and 1e11, 1e12, 1e13, 1e14 for case B

        if case == 'A':
            self.storey_file_path = (DATA_PATH + os.sep
                                     + 'storey_hummer_95_A1.dat')
        elif case == 'B':
            self.storey_file_path = (DATA_PATH + os.sep
                                     + 'storey_hummer_95_B1.dat')


        ## Create Balmer table
        self._read_storey_file(get_axes=True)
        # 48 atomic levels (2 -> 50) by X density levels by Y
        self.balmer_table = np.zeros((len(self.enu_axis),
                                      len(self.ne_axis),
                                      len(self.te_axis)), dtype=float) 

        # load Balmer table
        self._read_storey_file(get_axes=False)


    def _read_storey_file(self, get_axes=False):
        f = self.open_file(self.storey_file_path, 'r')
        lines = f.readlines()

        if get_axes:
            self.enu_axis = list()
            self.te_axis = list()
            self.ne_axis = list()

        for iline in range(len(lines)):
            line = lines[iline]
            if 'E_NU' in line:
                line = line.split('=')
                enu = int(line[1].split()[0].strip())
                z = int(line[2].split()[0].strip())
                te = float(line[3].split()[0].strip())
                ne = float(line[4].split()[0].strip())
                case = (line[5].split()[0].strip())
                if get_axes:
                    if not enu in self.enu_axis:
                        self.enu_axis.append(enu)
                    if not te in self.te_axis:
                        self.te_axis.append(te)
                    if not ne in self.ne_axis:
                        self.ne_axis.append(ne)

                if get_axes:
                    in_enu = False
                else:
                    in_enu = True

                ienu = 0
                while in_enu and iline + ienu < len(lines) - 1:
                    ienu += 1
                    line = lines[iline + ienu]
                    if 'E_NU' in line or 'R_NU' in line:
                        in_enu = False
                    else:
                        line = line.split()
                        if '2' in line:
                            self.balmer_table[
                                self._enu_index(enu),
                                self._ne_index(ne),
                                self._te_index(te)] = float(line[3])

        if get_axes:
            self.enu_axis.sort()
            self.enu_axis = np.array(self.enu_axis)
            self.te_axis.sort()
            self.te_axis = np.array(self.te_axis)
            self.ne_axis.sort()
            self.ne_axis = np.array(self.ne_axis)


    def _te_index(self, te):
        for i in range(len(self.te_axis)):
            if te == self.te_axis[i]:
                return i
        self._print_error(
            'Unknown temperature, must be in %s'%str(self.te_axis))

    def _ne_index(self, ne):
        for i in range(len(self.ne_axis)):
            if ne == self.ne_axis[i]:
                return i
        self._print_error(
            'Unknown density, must be in %s'%str(self.ne_axis))

    def _enu_index(self, enu):
        for i in range(len(self.enu_axis)):
            if enu == self.enu_axis[i]:
                return i
        self._print_error(
            'Unknown atomic level, must be in %s'%str(self.enu_axis))


    def get_ratio(self, te=1e4, ne=1000, nu=3):
        """Return ratio to Hbeta
        """
        hbeta_emission = self.balmer_table[self._enu_index(4),
                                           self._ne_index(ne),
                                           self._te_index(te)]

        return self.balmer_table[self._enu_index(nu),
                                 self._ne_index(ne),
                                 self._te_index(te)] / hbeta_emission



############################################
#### NSCalibration Class ###################
############################################
    
class NSCalibration(ORCSTools):
    """NS calibration from Pilyugin & Mattsson, MNRAS (2010)

    Transitions between cool, warm and hot regions are smoothed
    to avoid small discrepancies in the abundance maps while going
    from one region to another (i.e. one relation to another)
    """
    ZN = None
    ZO = None
    t2 = None
    
    N2 = None
    S2 = None
    R2 = None

    cool_reg = None
    warm_reg = None
    hot_reg = None

    maps = None
    
    def __init__(self, maps):

        SMOOTH_N2 = 0.05
        SMOOTH_N2_S2 = 0.05
        
        self.maps = maps
        self.N2 = ((self.maps.get_map(6548).get_data()
                    + self.maps.get_map(6583).get_data())
                   /self.maps.get_map(4861).get_data())
        self.S2 = ((self.maps.get_map(6716).get_data()
                    + self.maps.get_map(6731).get_data())
                   /self.maps.get_map(4861).get_data())
        self.R3 = ((self.maps.get_map(4959).get_data()
                    + self.maps.get_map(5007).get_data())
                   /self.maps.get_map(4861).get_data())
        
        # Cool HII regions (green) [t[NII] < 0.85 10^4 K]
        self.cool_reg = np.nonzero(np.log10(self.N2) >= -0.1 - SMOOTH_N2)
        self.warm_reg = np.nonzero(
            (np.log10(self.N2) < -0.1 + SMOOTH_N2)
            * (np.log10(self.N2/self.S2) >= -0.25 - SMOOTH_N2_S2))
        self.hot_reg = np.nonzero(
            (np.log10(self.N2) < -0.1 + SMOOTH_N2)
            * (np.log10(self.N2/self.S2) < -0.25 + SMOOTH_N2_S2))


    def get_ZO(self):
        # compute O abundance
        count_map = np.zeros_like(self.N2)
        self.ZO = Map(np.zeros_like(self.N2))
        self.ZO.data[self.cool_reg] += (
            8.454
            - 0.216 * np.log10(self.R3)
            - 0.362 * np.log10(self.S2)
            - 0.101 * np.log10(self.N2/self.S2))[self.cool_reg]
        count_map[self.cool_reg] += 1.
        self.ZO.data[self.warm_reg] += (
             8.456
             + 0.082 * np.log10(self.R3)
             + 0.391 * np.log10(self.N2)
             + 0.290 * np.log10(self.N2/self.S2))[self.warm_reg]
        count_map[self.warm_reg] += 1.
        self.ZO.data[self.hot_reg] += (
            7.881
            + 0.929 * np.log10(self.R3)
            + 0.650 * np.log10(self.N2)
            + 0.025 * np.log10(self.N2/self.S2))[self.hot_reg]
        count_map[self.hot_reg] += 1.

        self.ZO.data /= count_map
        self.ZO.header = self.maps.get_header(5007, 'Z(O) Map')

        return self.ZO
        
    def get_ZN(self):
        count_map = np.zeros_like(self.N2)
        self.ZN = Map(np.zeros_like(self.N2))
        self.ZN.data[self.cool_reg] += (
            7.414
            - 0.383 * np.log10(self.R3)
            + 0.119 * np.log10(self.S2)
            + 0.988 * np.log10(self.N2/self.S2))[self.cool_reg]
        count_map[self.cool_reg] += 1.
        self.ZN.data[self.warm_reg] += (
            7.250
            + 0.078 * np.log10(self.R3)
            + 0.529 * np.log10(self.N2)
            + 0.906 * np.log10(self.N2/self.S2))[self.warm_reg]
        count_map[self.warm_reg] += 1.
        self.ZN.data[self.hot_reg] += (
            6.599
            + 0.888 * np.log10(self.R3)
            + 0.663 * np.log10(self.N2)
            + 0.371 * np.log10(self.N2/self.S2))[self.hot_reg]
        count_map[self.hot_reg] += 1.

        self.ZN.data /= count_map
        self.ZN.header = self.maps.get_header(6583, 'Z(N) Map')

        return self.ZN

    def get_t2(self):
        count_map = np.zeros_like(self.N2)
        self.t2 = Map(np.zeros_like(self.N2))
        self.t2.data[self.cool_reg] += (
            1.185
            - 0.351 * np.log10(self.R3)
            - 0.273 * np.log10(self.S2)
            + 0.059 * np.log10(self.N2/self.S2))[self.cool_reg]
        count_map[self.cool_reg] += 1.
        self.t2.data[self.warm_reg] += (
            1.226
            - 0.219 * np.log10(self.R3)
            + 0.133 * np.log10(self.N2)
            + 0.225 * np.log10(self.N2/self.S2))[self.warm_reg]
        count_map[self.warm_reg] += 1.
        self.t2.data[self.hot_reg] += (
            0.953
            + 0.117 * np.log10(self.R3)
            + 0.230 * np.log10(self.N2)
            + 0.033 * np.log10(self.N2/self.S2))[self.hot_reg]
        count_map[self.hot_reg] += 1.

        self.t2.data /= count_map
        self.t2.data = (1. / self.t2.data) * 1e4
        self.t2.header = self.maps.get_header(6583, 'T(NII) Map in K')

        return self.t2

############################################
#### MISCELLANEOUS #########################
############################################


def get_image_shift(im1_path, im2_path, min_star_number=15):
    """Return shift along x ans y axis between two images containing
    stars.

    :param im1_path: Path to the 1st image
    :param im2_path: Path to the 2nd image
    :param min_star_number: (Optional) Minimum number of stars to use

    :return: a tuple (dx, dy)
    """ 
    im1 = Map(im1_path, rescale=True)
    fit_im1 = im1.fit_stars(min_star_number=min_star_number)
    star_list = fit_im1.get_star_list()
    im2 = Map(im2_path, rescale=True)


    fit_im2 = im2.fit_stars(star_list=star_list,
                            local_background=True,
                            precise_guess=True)
        
    good_star_list = [istar for istar in range(fit_im2.star_nb) if
                      fit_im2[istar] != None]
        
    dx_mean = np.mean(sigmacut(np.array([fit_im2[istar, 'dx']
                                         for istar in good_star_list]),
                               sigma=2.))
    dy_mean = np.mean(sigmacut(np.array([fit_im2[istar, 'dy']
                                         for istar in good_star_list]),
                               sigma=2.))

    return dx_mean, dy_mean
    
